#!/bin/sh
ENABLE_HOOKS=
DISABLE_HOOKS=

. /lib/brcmaliases.sh
. /lib/functions.sh
. /usr/share/libubox/jshn.sh
. /lib/network/ebtables.sh
[ -f /lib/network/anyfi.sh ] && . /lib/network/anyfi.sh
[ -f /lib/network/anyfi_broadcom.sh ] && . /lib/network/anyfi_broadcom.sh

exec >/dev/null 2>&1

local _enWifi=0
local _enWps=0
local _rstDnsMsq=0
local _vno=0
local _cno=0
local acsifs=""
local staifs=""
local wetifs=""

set_bridge() {
	local br=$1
	brctl stp $br off
	brctl setfd $br 0
	sendarp -s $br -d $br
}

map_networks() {
	local ifdev ifobj devtype
	local devs=""
	local _acnt=0
	for ifobj in `ubus list network.interface.\*`; do
		interface="${ifobj##network.interface.}"
		(
			[ "$_acnt" == "0" ] && _acnt=""
			[ "$interface" == "loopback" ] && continue
			json_load "$(ifstatus $interface)"
			json_get_var ifdev device
			if [[ -n "$ifdev" ]]; then
				nvram set lan"$_acnt"_ifname="$ifdev"
				json_load "$(devstatus $ifdev)"
				json_get_var devtype type
				if [[ "$devtype" = "Bridge" ]]; then
					_i=1
					set_bridge $ifdev
					json_select bridge-members
					while json_get_var dev $_i; do
						[ -z "$devs" ] && devs="$dev" || devs="$devs $dev"
						_i=$(($_i + 1))
					done
					nvram set lan"$_acnt"_ifnames="$devs"
				else
					nvram set lan"$_acnt"_ifnames="$ifdev"
				fi
			fi
		)
		_acnt=$((_acnt+1))
	done
}

netno() {
	local network="$1"
	local ifobj
	local _acnt=0
	for ifobj in `ubus list network.interface.\*`; do
		interface="${ifobj##network.interface.}"
		(
			[ "$_acnt" == "0" ] && _acnt=""
			[ "$interface" == "loopback" ] && continue
			if [ "$interface" == "$network" ]; then
				echo "$_acnt"
				break
			fi
		)
		_acnt=$((_acnt+1))
	done
}

find_network() {
	local device="$1"
	local ifdev ifl3dev ifobj devtype
	for ifobj in `ubus list network.interface.\*`; do
		interface="${ifobj##network.interface.}"
		[ "$interface" == "loopback" ] && continue
		json_load "$(ifstatus $interface)"
		json_get_var ifdev device
		json_get_var ifl3dev l3_device
		if [[ "$device" = "$ifdev" ]] || [[ "$device" = "$ifl3dev" ]]; then
			echo "$interface"
			return
		else
			json_load "$(devstatus $ifdev)"
			json_get_var devtype type
			if [[ "$devtype" = "Bridge" ]]; then
				_i=1
				json_select bridge-members
				while json_get_var dev $_i; do
					if [[ "$dev" = "$device" ]]; then
						echo "$interface"
						return
					fi
					_i=$(($_i + 1))
				done
			fi
		fi
	done
}

create_qr_code() {
	local wssd=$1
	local wenc=$2
	local wkey=$3
	local whid=$4
	qrencode -o /www/luci-static/resources/icons/wqr_$wssd.png "WIFI:T:$wenc;S:$wssd;P:$wkey;H:$whid;"
}

set_wifi_down() {
	local device="$1"
	local network
	
	if [ -n "$2" ] && [ "$device" != "$2" ]; then
		continue
	fi

	uci_revert_state wireless "$device"
	wlctl -i $device down

	for iface in $(grep "$device" /proc/net/dev | awk -F':' '{print$1}'); do
		# remove ebtables wme rules
		remove_ebtables_wme_rules $iface

		network="$(find_network $iface)"
		wlctl -i "$iface" bss down
		wlctl -i "$iface" ssid ""
		ifconfig "$iface" down >/dev/null 2>&1 && {
			[ -n "$network" ] && ubus call network.interface."$network" remove_device "{ \"name\": \"$iface\" }" 2>/dev/null && uci_revert_state wireless "$iface"
		}
	done
	ledctl wireless off
}

set_wifi_up() {
	local cfg="$1"
	local ifname="$2"

	uci_set_state wireless "$cfg" up 1
	uci_set_state wireless "$cfg" ifname "$ifname"

	# add ebtables wme rules
	wlctl -i $iface wme | grep "1" && add_ebtables_wme_rules $iface
}

create_vif() {
	local vif="$1"
	local device
	local iface
	local network

	config_get device "$vif" device
	config_get network "$vif" network

	if [ "$2" == "$device" ]; then
		wlctl -i $device bss -C $_cno down
		wlctl -i $device ssid -C $_cno ""

		[ $_cno -eq 0 ] && iface="$device" || iface="$device"."$_cno"
		# tag guestMgr interface
		[ "$network" == "guestMgr" ] && {
			nvram set wl_guestmgr_ifname="$iface"
			nvram set wl_guestmgr_cfgno="$vif"
		}
		# check if dnsmasq restart needed
		for ifc in $(uci get dhcp.@dnsmasq[0].interface); do
			if [ "$ifc" == "$iface" ]; then
				uci del_list dhcp.@dnsmasq[0].interface="$iface"
				uci commit dhcp
				_rstDnsMsq=$(($_rstDnsMsq + 1))
				break
			fi
		done
		_cno=$(($_cno + 1))
	fi
}

remove_wlifs_from_dnsmasq_bind_list() {
	local ifc
	for ifc in $(uci get dhcp.@dnsmasq[0].interface); do
		case "$ifc" in
			wl*)
				uci del_list dhcp.@dnsmasq[0].interface="$ifc"
				uci commit dhcp
				_rstDnsMsq=$(($_rstDnsMsq + 1))
			;;
		esac
	done
}

dnsmasq_bind_check() {
	local iface="$1"
	local network="$2"
	local dnsmasq="0"
	local bridged="0"
	local dhcpnet="0"
	local dhcpat="$(uci -q get dhcp.$network)"
	local dhcpignr="$(uci -q get dhcp.$network.ignore)"
	local nwldcrd="$(uci -q get dhcp.@dnsmasq[0].nonwildcard)"
	local found="0"

	if [ "$(uci get network.$network.type)" == "bridge" ]; then
		bridged="1"
	fi
	if [ -n "$dhcpat" ] && [ "$dhcpignr" != "1" ]; then
		dhcpnet="1"
	fi
	if [ "$bridged" == "0" ] && [ "$dhcpnet" == "1" ] && [ "$nwldcrd" == "1" ]; then
		dnsmasq="1"
	fi
	if [ "$dnsmasq" == "1" ] ; then
		uci add_list dhcp.@dnsmasq[0].interface="$iface"
		uci commit dhcp
		_rstDnsMsq=$(($_rstDnsMsq + 1))
	fi
}

wireless_mode() {
	local mode="$1"
	local network="$2"
	local bridged="0"
	local wmode=""

	[ "$(uci get network.$network.type)" == "bridge" ] && bridged="1"

	case "$mode" in
		ap) wmode="ap" ;;
		sta) [ "$bridged" == "1" ] && wmode="wet" || wmode="sta" ;;
	esac
	echo $wmode
}

set_wifi_iface() {
	local vif="$1"
	local device
	local vifs
	local wmode

	config_get device "$vif" device

	if [ "$2" == "$device" ]; then
		config_get network "$vif" network
		config_get mode "$vif" mode
		config_get ssid "$vif" ssid
		config_get macfilter "$vif" macfilter
		local maclist="$(uci -q get wireless.@wifi-iface[$_vno].maclist)" #config_get maclist "$vif" maclist
		config_get_bool wmf_bss_enable "$vif" wmf_bss_enable
		config_get_bool wmm_bss_disable "$vif" wmm_bss_disable
		config_get bss_max "$vif" bss_max
		config_get_bool isolate "$vif" isolate
		config_get_bool hidden "$vif" hidden
		config_get_bool disabled "$vif" disabled
		config_get enc "$vif" encryption
		config_get cipher "$vif" cipher
		config_get_bool autoconf "$vif" autoconf
		local qr_enc="nopass"
		local qr_hidden=false
		local qr_key="no"

		if [ $_vno -eq 0 ]; then
			iface="$device"
			nif="$device"
		else
			iface="$device"."$_vno"
			nif="$device"_"$_vno"

			# set NAS alternate if multi SSIDs are used
			nvram set nas_alternate=1
		fi

		# tag guestMgr interface
		[ "$network" == "guestMgr" ] && {
			nvram set wl_guestmgr_ifname="$iface"
			nvram set wl_guestmgr_cfgno="$vif"
		}

		# set wireless VIFs in broadcom nvram
		vifs=$(nvram get "$device"_vifs)
		[ -z "$vifs" ] && vifs="$iface" || vifs="$vifs $iface"
		nvram set "$device"_vifs="$vifs"

		# create wireless VIFs
		wlctl -i $device bss -C $_vno down
		wlctl -i $device bss -C $_vno up
		wlctl -i $device ssid -C $_vno "$ssid"

		nvram set "$nif"_ifname="$iface"
		nvram set "$nif"_ssid="${ssid:-Inteno}"

		# set Mode
		wmode="$(wireless_mode $mode $network)"
		nvram set "$nif"_mode="${wmode:-ap}"
		[ "$wmode" == "sta" ] && staifs="$staifs $iface"
		[ "$wmode" == "wet" ] && wetifs="$wetifs $iface"

		# set Radio Infra
		nvram set "$nif"_radio=1
		nvram set "$nif"_infra=1

		# set MAC filter
		wlctl -i $iface macmode "${macfilter:-0}"
		wlctl -i $iface mac none
		[ -n "$maclist" ] && {
			for mac in $maclist; do
				wlctl -i $iface mac $mac
			done
		}

		# set WMF
		wlctl -i $iface wmf_bss_enable "${wmf_bss_enable:-1}" || dhdctl -i $iface wmf_bss_enable "${wmf_bss_enable:-1}"

		# set WME
		wlctl -i $iface wme_bss_disable "${wmm_bss_disable:-0}"

		# set BSS MAX assoc
		wlctl -i $iface bss_maxassoc "${bss_max:-16}"

		# set AP isolate and hidden
		wlctl -i $iface ap_isolate "${isolate:-0}"
		wlctl -i $iface closed "${hidden:-0}"
		[ "$hidden" == "1" ] && qr_hidden=true

		# set VLAN mode
		wlctl -i $iface vlan_mode 0

		# set Encryption
		local key=
		local wsec=0
		local wsec_r=0
		local eap=0
		local eap_r=0
		local auth=0
		wlctl -i $device down
		wlctl -i $iface auth 0
		nvram set "$nif"_auth=0
		nvram set "$nif"_preauth=0
		nvram set "$nif"_net_auth_type=1
		nvram set "$nif"_wep=disabled
		case "$enc" in
			*wep*)
				wsec_r=1
				wsec=1
				nvram set "$nif"_wep=enabled
				config_get key "$vif" key
				case "$enc" in
					*shared*) wlctl -i $iface auth 1; nvram set "$nif"_auth=1;;
				esac
				case "$key" in
					[1234])
						for knr in 1 2 3 4; do
							echo "wlctl -i $iface rmwep $(($knr - 1))" >> /tmp/wepset
							config_get k "$vif" key$knr
							[ "$knr" == "$key" ] && qr_key="$k"
							[ -n "$k" ] || continue
							echo "wlctl -i $iface addwep $(($knr - 1)) $k" >> /tmp/wepset
						done
						echo "wlctl -i $iface primary_key $(($key - 1))" >> /tmp/wepset
					;;
					*)
						if [ -n "$key" ]; then
							echo "wlctl -i $iface rmwep 0" >> /tmp/wepset
							echo "wlctl -i $iface addwep 0 $key" >> /tmp/wepset
							echo "wlctl -i $iface primary_key 0" >> /tmp/wepset
							qr_key="$key"
						fi
					;;
				esac
				qr_enc="WEP"
			;;
			*psk*)
				wsec_r=1
				eap=1
				eap_r=1
				config_get key "$vif" key
				config_get gtk "$vif" gtk_rekey

				nvram set "$nif"_wpa_gtk_rekey="${gtk:-0}"

				# psk version + default cipher
				case "$enc" in
					*mixed*|*psk+psk2*) auth=132; wsec=6; nvram set "$nif"_akm='psk psk2'; nvram set "$nif"_crypto=tkip+aes;;
					*psk2*) auth=128; wsec=4; nvram set "$nif"_akm=psk2; nvram set "$nif"_crypto=aes;;
					*) auth=4; wsec=2; nvram set "$nif"_akm=psk; nvram set "$nif"_crypto=tkip;;
				esac

				# cipher override
				case "$cipher" in
					*tkip+aes*|*tkip+ccmp*|*aes+tkip*|*ccmp+tkip*) wsec=6; nvram set "$nif"_crypto=tkip+aes;;
					*aes*|*ccmp*) wsec=4; nvram set "$nif"_crypto=aes;;
					*tkip*) wsec=2; nvram set "$nif"_crypto=tkip;;
				esac
				nvram set "$nif"_wpa_psk="$key"
				nvram set "$nif"_auth_mode="psk"
				qr_enc="WPA"
				qr_key="$key"
			;;
			*wpa*)
				wsec_r=1
				eap=1
				eap_r=1
				config_get key "$vif" key
				#config_get server "$vif" server
				#config_get port "$vif" port
				config_get rad_serv "$vif" radius_server
				config_get rad_port "$vif" radius_port
				config_get rad_sec "$vif" radius_secret
				config_get net_reauth "$vif" key net_reauth

				nvram set "$nif"_net_reauth="${net_reauth:-36000}"

				# wpa version + default cipher
				case "$enc" in
					*mixed*|*wpa+wpa2*) auth=66; wsec=6; nvram set "$nif"_akm='wpa wpa2'; nvram set "$nif"_crypto=tkip+aes;;
					*wpa2*) auth=64; wsec=4; nvram set "$nif"_akm=wpa2; nvram set "$nif"_crypto=aes;;
					*) auth=2; wsec=2; nvram set "$nif"_akm=wpa; nvram set "$nif"_crypto=tkip;;
				esac

				# cipher override
				case "$cipher" in
					*tkip+aes*|*tkip+ccmp*|*aes+tkip*|*ccmp+tkip*) wsec=6; nvram set "$nif"_crypto=tkip+aes;;
					*aes*|*ccmp*) wsec=4; nvram set "$nif"_crypto=aes;;
					*tkip*) wsec=2; nvram set "$nif"_crypto=tkip;;
				esac
				nvram set "$nif"_wpa_psk="$key"
				nvram set "$nif"_auth_mode="radius"
				nvram set "$nif"_radius_ipaddr="$rad_serv"
				nvram set "$nif"_radius_port="${rad_port:-1812}"
				nvram set "$nif"_radius_key="$rad_sec"
				qr_enc="WPA"
				qr_key="$key"
			;;
		esac
		case "$wmode" in
			sta|wet) nvram set "$nif"_auth_mode="none" ;;
		esac
		wlctl -i $iface wsec $wsec
		wlctl -i $iface wpa_auth $auth
		wlctl -i $iface wsec_restrict $wsec_r
		wlctl -i $iface eap $eap
		wlctl -i $iface eap_restrict $eap_r

		# create QR code of the Wi-Fi network
		create_qr_code "$ssid" "$qr_enc" "$qr_key" "$qr_hidden"

		# tag apsta interfaces
		if [ "$(uci -q get wireless.$device.apsta)" == "1" ]; then
			if [ "$mode" == "sta" ]; then
				# tag sta interface
				nvram set wl_apsta_sta_ifname="$iface"
				nvram set wl_apsta_sta_cfg="$vif"
				nvram set wl_apsta_sta_net="$network"
#			else
#				# tag ap interface
#				nvram set wl_apsta_ap_ifname="$iface"
#				nvram set wl_apsta_ap_cfg="$vif"
#				nvram set wl_apsta_ap_net="$network"
			fi
		fi

		# tag autoconf interfaces
		if [ "$autoconf" == "1" ]; then
			nvram set wl_autoconf_ap_ifnames="$iface $(nvram get wl_autoconf_ap_ifnames)"
			nvram set wl_autoconf_ap_cfgs="$vif $(nvram get wl_autoconf_ap_cfgs)"
			nvram set wl_autoconf_ap_net="$network"
		fi

		# set WPS
		config_get wps_mode "$vif" wps_pbc
		if [ "$wps_mode" == "1" ]; then
			nvram set "$nif"_wps_mode="enabled"
			nvram set router_disable="0"
			nvram set wps_modelnum="123456"
			nvram set boardnum="1234"
			nvram set wps_modelname="Broadcom"
			nvram set wps_mfstring="Broadcom"
			nvram set wps_device_name="$(uci -q get wireless.@wifi-iface[0].ssid)"
			nvram set wps_version2="enabled"
			lno=$(netno $network)
			nvram set lan"$lno"_wps_reg="enabled"
			nvram set lan"$lno"_wps_oob="disabled"
			nvram set wps_proc_status="0"
			nvram set wps_button_gpio=`db get -q hw.board.wpsButtonGpio`
			if [ "$(uci -q get wireless.$device.apsta)" == "1" ]; then
				nvram set "$device"_ure_mode="wre"
				nvram set wps_pbc_apsta="enabled"
				nvram set wps_pbc_method="2"
				[ "$mode" == "sta" ] && nvram set wps_pbc_sta_ifname="$iface" || nvram set wps_pbc_ap_ifname="$iface"
			fi
			nvram set wps_config="DONE"
			_enWps=$(($_enWps + 1))
		else
			nvram set "$nif"_wps_mode="disabled"
		fi

		# bring up the VIF and add to network
		wlctl -i $device bss -C $_vno down
		wlctl -i $device bss -C $_vno up
		wlctl -i $device down
		local permac curmac
		local perethr=$(wlctl -i $iface perm_etheraddr | awk '{print$2}')
		local curethr=$(wlctl -i $iface cur_etheraddr | awk '{print$2}')
		if [ "$curethr" == "00:00:00:00:00:00" ]; then
#			permac=${perethr//:/}
#			curmac=$(printf "%X\n" $((0x$curmac + 1)) | sed s/./2/2 | sed 's/[[:xdigit:]]\{2\}/:&/g' | awk -F'^:' '{print$2}')
#			curethr=$curmac
			curethr=$perethr
			wlctl -i $iface cur_etheraddr $curethr
			wlctl -i $iface bssid $curethr
		fi
		ifconfig $iface hw ether $curethr 2>/dev/null
		nvram set "$nif"_hwaddr="$curethr"
		ifconfig "$iface" up >/dev/null 2>&1 && {
			[ -n "$network" ] && ubus call network.interface."$network" add_device "{ \"name\": \"$iface\" }" 2>/dev/null
		}
		set_wifi_up "$vif" "$iface"

		# check if VIF is disabled in config
		wlctl -i $iface bss down
		if [ "$disabled" == "1" ]; then
			nvram set "$nif"_bss_enabled=0
		else
			nvram set "$nif"_bss_enabled=1
			wlctl -i $iface bss up
		fi

		# check if dnsmasq should bind to this interface
		dnsmasq_bind_check $iface $network

		_vno=$(($_vno + 1))
	fi
}

set_wifi_device() {
	local device="$1"
	config_get band "$device" band
	config_get bandwidth "$device" bandwidth
	config_get channel "$device" channel
	config_get scantimer "$device" scantimer
	config_get country "$device" country
	config_get maxassoc "$device" maxassoc
	config_get wds "$device" wds
	config_get distance "$device" distance
	config_get slottime "$device" slottime
	config_get rxantenna "$device" rxantenna
	config_get txantenna "$device" txantenna
	config_get_bool frameburst "$device" frameburst
	config_get macaddr "$device" macaddr
	config_get txpower "$device" txpower
	config_get pwr_percent "$device" pwr_percent
	config_get frag "$device" frag
	config_get rts "$device" rts
	config_get dtim_period "$device" dtim_period
	config_get beacon_int "$device" beacon_int
	config_get hwmode "$device" hwmode
	config_get rate "$device" rate
	config_get rateset "$device" rateset
	config_get rxchainps "$device" rxchainps
	config_get rxchainps_qt "$device" rxchainps_qt
	config_get rxchainps_pps "$device" rxchainps_pps
	config_get rifs "$device" rifs
	config_get rifs_advert "$device" rifs_advert
	config_get obss_coex "$device" obss_coex
	config_get wmm "$device" wmm
	config_get wmm_noack "$device" wmm_noack
	config_get wmm_apsd "$device" wmm_apsd
	config_get doth "$device" doth
	config_get radio "$device" radio
	config_get apsta "$device" apsta

	if [ "$radio" == "off" ]; then
		config_foreach create_vif wifi-iface "$device"
		_cno=0
		continue
	else
		_enWifi=$(($_enWifi + 1))
	fi
	
	if [ -n "$2" ] && [ "$device" != "$2" ]; then
		continue
	fi

	# BASE settings
	# wlctl -i $device cap > /var/cap_$device
	# wlctl -i $device phy_watchdog 0
	wlctl -i $device stbc_rx 0
	wlctl -i $device stbc_tx -1
	wlctl -i $device fcache 1 || dhdctl -i $device fcache 1
	wlctl -i $device wnm 0x103

	# WDS Settings
	wlctl -i $device wds none
	wlctl -i $device wdswsec 0
	wlctl -i $device wdswsec_enable 0

	# mode settings
	wlctl -i $device up
	wlctl -i $device down
	wlctl -i $device apsta "${apsta:-0}"
	nvram set "$device"_apsta="${apsta:-0}"
	wlctl -i $device ap 1
	wlctl -i $device wet 0
	wlctl -i $device mpc 0
	wlctl -i $device infra 1
	wlctl -i $device closed 0
	wlctl -i $device radar 1

	wlctl -i $device country "${country:-EU/13}"
	wlctl -i $device band "${band:-b}"

	# regulatory and spectrum management settings
	wlctl -i $device regulatory 0
	wlctl -i $device spect 1
	case "$doth" in
		1)
			wlctl -i $device regulatory 0
			wlctl -i $device spect 1
		;;
		2)
			wlctl -i $device regulatory 0
			wlctl -i $device spect 2
		;;
		3)
			wlctl -i $device regulatory 1
			wlctl -i $device spect 0
		;;
#		0)
#			wlctl -i $device regulatory 0
#			wlctl -i $device spect 0
#		;;
	esac

	# set HW bandwidth and mode
	wlctl -i $device mimo_preamble 2
	wlctl -i $device mimo_bw_cap 0
	wlctl -i $device bw_cap 2g 0x1
	wlctl -i $device bw_cap 5g 0x3
	wlctl -i $device obss_coex "${obss_coex:-1}"

	wlctl -i $device gmode 1
	wlctl -i $device gmode_protection 1
	wlctl -i $device gmode_protection_override -1
	wlctl -i $device gmode_protection_control 2
	wlctl -i $device nmode -1
	wlctl -i $device nreqd 0
	wlctl -i $device vhtmode 0
	wlctl -i $device nmode_protection_override -1
	wlctl -i $device protection_control 2

	case "$bandwidth" in
		80)
			wlctl -i $device mimo_bw_cap 2
			wlctl -i $device bw_cap 2g 0x1
			wlctl -i $device bw_cap 5g 0x7
		;;
		40)
			wlctl -i $device mimo_bw_cap 2
			wlctl -i $device bw_cap 2g 0x3
			wlctl -i $device bw_cap 5g 0x3
		;;
		20)
			wlctl -i $device bw_cap 2g 0x1
			wlctl -i $device bw_cap 5g 0x1
		;;
	esac

	case "$hwmode" in
		*a)
			wlctl -i $device nmode 0
		;;
		*b)
			wlctl -i $device nmode 0
			wlctl -i $device gmode 0
		;;
		*bg)
			wlctl -i $device nmode 0
			wlctl -i $device gmode 1
		;;
		*g)
			wlctl -i $device nmode 0
			wlctl -i $device gmode 2
		;;
		*gst)
			wlctl -i $device gmode 4
		;;
		*lrs)
			wlctl -i $device gmode 5
		;;
		*n)
			wlctl -i $device nmode 1
			wlctl -i $device nreqd 1
		;;
		*ac)
			wlctl -i $device nmode 3
			wlctl -i $device nreqd 1
			wlctl -i $device vhtmode 1
		;;
	esac

	# set rate
	wlctl -i $device rateset "${rateset:-default}"
	wlctl -i $device rate "${rate:-0}"
	wlctl -i $device bg_rate 0
	wlctl -i $device mrate 0
	wlctl -i $device bg_mrate 0

	# set rifs
	wlctl -i $device rifs "${rifs:-0}"
	wlctl -i $device rifs_advert "${rifs_advert:-0}"

	# set channel
	case "$channel" in
		auto)
			if [ -n "$acsifs" ]; then
				nvram set acs_ifnames="$acsifs $device"
			else
				nvram set acs_ifnames="$device"
			fi
			acsifs="$(nvram get acs_ifnames)"
			[ -n "$scantimer" ] && cstmr=$(($scantimer*60))
			nvram set "$device"_acs_chan_dwell_time="70"
			nvram set "$device"_acs_chan_flop_period="70"
			nvram set "$device"_acs_ci_scan_timeout="300"
			nvram set "$device"_acs_ci_scan_timer="4"
			nvram set "$device"_acs_cs_scan_timer="${cstmr:-900}"
			nvram set "$device"_acs_dfs="1"
			nvram set "$device"_acs_dfsr_activity="30 10240"
			nvram set "$device"_acs_dfsr_deferred="604800 5"
			nvram set "$device"_acs_dfsr_immediate="300 3"
			nvram set "$device"_acs_excl_chans=""
			nvram set "$device"_acs_fcs_mode="1"
			nvram set "$device"_acs_scan_entry_expire="3600"
			nvram set "$device"_acs_tx_idle_cnt="5"
			nvram set "$device"_acs_lowband_least_rssi="-75"
			wlctl -i $device chanim_mode 2

			# temporary autochannel method
			wlctl -i $device csscantimer "${scantimer:-15}"
			wlctl -i $device up
			wlctl -i $device autochannel 1
			wlctl -i $device chanspec $(wlctl -i $device autochannel | awk '{print$1}')
			wlctl -i $device down
		;;
		*)
			wlctl -i $device chanspec $channel
		;;
	esac

	# set MAX assoc
	wlctl -i $device maxassoc "${maxassoc:-16}"

	# WME settings
	wlctl -i $device wme 0
	wlctl -i $device afterburner_override 0
	wlctl -i $device ampdu 1
	wlctl -i $device amsdu 0
	wlctl -i $device rx_amsdu_in_ampdu 0
	wlctl -i $device wme "${wmm:-1}"
	wlctl -i $device wme_noack "${wmm_noack:-0}"
	wlctl -i $device wme_apsd "${wmm_apsd:-1}"
	wlctl -i $device wme_bss_disable "${wmm_bss_disable:-0}"

	# tweak Settings
	wlctl -i $device rtsthresh "${rts:-2347}"
	wlctl -i $device fragthresh "${frag:-2346}"
	wlctl -i $device dtim "${dtim_period:-1}"
	wlctl -i $device bi "${beacon_int:-100}"
	wlctl -i $device frameburst "${frameburst:-0}"
	wlctl -i $device noise_metric 1

	# power settings
	wlctl -i $device antdiv "${rxantenna:-3}"
	wlctl -i $device txant "${txantenna:-3}"
	wlctl -i $device pwr_percent "${txpower:-100}"
	wlctl -i $device rxchain_pwrsave_stas_assoc_check 1
	wlctl -i $device radio_pwrsave_stas_assoc_check 1
	wlctl -i $device rxchain_pwrsave_enable "${rxchainps:-0}"
	wlctl -i $device rxchain_pwrsave_quiet_time "${rxchainps_qt:-10}"
	wlctl -i $device rxchain_pwrsave_pps "${rxchainps_pps:-10}"


	# create and configure wireless VIFs
	wlctl -i $device down
	wlctl -i $device mbss 1
	config_foreach set_wifi_iface wifi-iface "$device"
	_vno=0

	# bring up the wireless device
	wlctl -i $device leddc 0
	ledctl wireless on

	wlctl -i $device down
	wlctl -i $device up
	wlctl -i $device radarthrs 0x6ae 0x30 0x6a8 0x30 0x6a4 0x30 0x6aa 0x30 0x6aa 0x30 0x6a4 0x30
}

generate_wireless_config() {
	local wls="wl0 wl1"
	local bands band bwidth country hwmode pcid
	local BMAC=$(cat /proc/nvram/BaseMacAddr | tr '[a-z]' '[A-Z]')
	BMAC=${BMAC// /}
	local BSSID=$(printf "%X\n" $((0x$BMAC + 2)))
	local BSSID4=${BSSID:6:4}
	local WPAKEY=$(cat /proc/nvram/WpaKey)
	WPAKEY="${WPAKEY:-1234567890}"

	pcID() {
		wlctl -i $wl revinfo | awk 'FNR == 2 {print}' | cut -d'x' -f2
	}
	is5G() {
		[ "$(db get hw.$1.bands)" == "a" ] && return 0 || return 1
	}
	isAC() {
		[ "$(db get hw.$1.is_ac)" == "1" ] && return 0 || return 1
	}

	for wl in $wls; do
		if wlctl -i $wl ap >/dev/null 2>&1; then
			if ! uci get wireless.$wl >/dev/null 2>&1; then
				pcid=$(pcID $wl)
				country="EU/13"
				hwmode="auto"
				if $(is5G $pcid); then
					band="a"
					bwidth="40"
					$(isAC $pcid) && hwmode="11ac"
				else
					band="b"
					bwidth="20"
				fi
				cat >> /etc/config/wireless <<EOF
config wifi-device '$wl'
	option type 'broadcom'
	option country '$country'
	option band '$band'
	option bandwidth '$bwidth'
	option hwmode '$hwmode'
	option channel 'auto'
	option scantimer '15'
	option wmm '1'
	option wmm_noack '0'
	option wmm_apsd '0'
	option txpower '100'
	option rateset 'default'
	option frag '2346'
	option rts '2347'
	option dtim_period '1'
	option beacon_int '100'
	option rxchainps '0'
	option rxchainps_qt '10'
	option rxchainps_pps '10'
	option rifs '0'
	option rifs_advert '0'

config wifi-iface
	option device '$wl'
	option network 'lan'
	option mode 'ap'
	option ssid 'Inteno-$BSSID4'
	option encryption 'pskmixedpsk2'
	option key '$WPAKEY'
	option gtk_rekey '3600'
	option macfilter '0'
	option wps_pbc '1'
	option wmf_bss_enable '1'

EOF
			fi
		fi
	done

}

set_tp_id() {
	wlctl -i wl1 ap || wlctl -i wl0 tp_id 1
}

handle_wep() {
	case "$1" in
		init)
			echo "#/bin/sh" > /tmp/wepset
			chmod u+x /tmp/wepset
		;;
		set)
			# set wepkeys if configured
			if [ -f /tmp/wepset ]; then
				sh /tmp/wepset
				rm /tmp/wepset
			fi
		;;
	esac
}

# restart dnsmasq if necessary
restart_dnsmasq() {
	if [ $_rstDnsMsq -gt 0 ] && [ -f /var/run/dnsmasq.pid ]; then
		kill -9 $(ps | grep dnsmasq | grep /etc/init.d | awk '{print$1}') 2>/dev/null
		/etc/init.d/dnsmasq restart
	fi
}

# Run all hook functions $2...$N for each config entry $1
run_hooks() {
	local arg="$1"; shift
	for func in "$@"; do
		config_foreach $func $arg
	done
}

bringup_sta() {
	for staif in $staifs; do
		dhprc="$(ps | grep udhcpc | grep -w $staif | awk '{print$1}')"
		if [ -n "$dhprc" ]; then
			wlctl -i $staif bss up
			kill -9 $dhprc
		fi
	done

	for wetif in $wetifs; do
		wlctl -i $wetif wet 1
		wlctl -i $wetif bss up
	done
}

case "$1" in
	disable|enable)
		[ -z "$2" ] && exit
		local wif="$2"
		local wdev="${wif:0:3}"
		local nif="$(echo $wif | sed 's/\./_/g')"
#		wlctl -i $wdev down
		if [ "$1" == "disable" ]; then
			nvram set "$nif"_bss_enabled=0
			wlctl -i $wif bss down
		else
			nvram set "$nif"_bss_enabled=1
			wlctl -i $wif bss up
		fi
#		if [ "$(uci -q get wireless.$wdev.radio)" != "off" ]; then
#			wlctl -i $wdev up
#		fi
		exit
	;;
esac

# kill related daemons
killall -9 eapd 2>/dev/null
killall -9 nas 2>/dev/null
killall -9 acsd 2>/dev/null
killall -9 wps_monitor 2>/dev/null

# remove wps_monitor pid file
rm -f /tmp/wps_monitor.pid

# remove all QR code images
rm -f /www/luci-static/resources/icons/wqr_*

# remove guestMgr interface tag
nvram set wl_guestmgr_ifname=""
nvram set wl_guestmgr_cfgno=""

# remove wireless interfaces from dnsmasq bind interface list
remove_wlifs_from_dnsmasq_bind_list

# clean NVRAM parameters and set debug mode
sed -i '/option/ d' /etc/config/broadcom
nvram set init=1
nvram set debug=0

config_load wireless

case "$1" in
	detect)
		generate_wireless_config
	;;
	down)
		config_foreach set_wifi_down wifi-device $2
		run_hooks wifi-device $DISABLE_HOOKS
		restart_dnsmasq
	;;
	*)
		set_tp_id
		config_foreach set_wifi_down wifi-device $2
		run_hooks wifi-device $DISABLE_HOOKS
		handle_wep "init"
		config_foreach set_wifi_device wifi-device $2
		handle_wep "set"
		restart_dnsmasq

		if [ $_enWifi -gt 0 ]; then
			ledctl eco off
		else
			ledctl eco on
			nvram set wlmngr=done
			exit
		fi

		# map all interfaces to corresponding networks by nvram parameters
		map_networks

		# start anyfi daemons
		run_hooks wifi-device $ENABLE_HOOKS

		# start related daemons
		[ -n "$acsifs" ] && acsd
		eapd
		nas
		[ $_enWps -gt 0 ] && wps_monitor &

		bringup_sta
	;;
esac

nvram set wlmngr=done

